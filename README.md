# Cartesian tree container
[Тестовое задание для компании Syntacore](https://syntacore.com/media/files/trial_task_tools.pdf)

Класс, представляющий из себя расширенное сбалансированное дерево, хранящее ключи и предоставляющее интерфейс для выполнения двух следующих запросов:
- Запрос (m i) на поиск i-го наименьшего элемента (k-ая наименьшая статистика)
- Запрос (n j) на поиск количества элементов, меньших, чем заданный j

## Установка и запуск
1. Склонировать этот репозиторий
2. Запустить скрипт сборки с помощью запуска `bash build.sh`
3. Запустить исполняемый файл `./build/syntacore-tools-trial-task`

Программа принимает три команды:
- Запрос (m i) на поиск i-го наименьшего элемента (k-ая наименьшая статистика)
- Запрос (n j) на поиск количества элементов, меньших, чем заданный j
- Запрос (k j) на добавление ключа j в дерево

## Алгоритм работы 
Дерево балансируется с помощью дополнительного поля(prior_) в каждой вершине. Оно инициализируется случайным значением. [Доказательство глубины в логарифм](https://neerc.ifmo.ru/wiki/index.php?title=Декартово_дерево#.D0.A1.D0.BB.D1.83.D1.87.D0.B0.D0.B9.D0.BD.D1.8B.D0.B5_.D0.BF.D1.80.D0.B8.D0.BE.D1.80.D0.B8.D1.82.D0.B5.D1.82.D1.8B).

Логарифмическая сложность операций нахождения k-ой статистики и кол-ва числе меньше достигается из-за добавления в вершину поля size, обозначающую размер поддерева и её обновление с помощью скрытой функции recalc(), вызов которой происходит при каждом изменении правого или левого ребёнка ноды.

### Реализация алгоритма поиска k-ой статистики
1. Находим размер левого поддерева корня
2. Если размер поддерева равен номеру статистики, то это корень
3. Если размер поддерева больше номера статистики, то спускаемся в левое поддерево и повторяем процесс
4. Если размер поддерева меньше номера статистики, то уменьшаем k на (размер левого поддерева + 1), спускаемся в правое поддерево и повторяем процесс

Можно увидеть, что кол-во вершин которые обошли будет равняться высоте дерева => logN

### Реализация алгоритма поиска кол-ва чисел меньших чем k
1. Пока ключ текущей вершины меньше k спускаемся в правое поддерево
2. Как только встретили ключ >= k или обошли все вершины возвращаем величину равную (размер всего дерева - размер первого неподходящего поддерева)

Можно увидеть, что кол-во вершин которые обошли будет равняться высоте дерева => logN

## Тестирование

Тестовые файлы представлены в директории tests

- test1.in - Проверка корректной работы дерева с одной вершиной в нём
- test2.in - Проверка корректной работы дерева с нулём вершин в нём
- test3.in - Проверка корректной работы заполненного дерева с тремя вершинами при поиске кол-ва вершин меньших чем значение одной из вершин(проверка на строгость условий)
- test4.in - Проверка корректной работы дерева с отрицательными ключами в вершинах и также проверка на строгость при отрицательных значениях